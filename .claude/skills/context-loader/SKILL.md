---
name: context-loader
description: "Load project context before implementation. Reads task document to understand scope, then analyzes codebase patterns, architecture, and related code. Use at start of /si."
context: fork
agent: Explore
allowed-tools:
  - Read
  - Grep
  - Glob
  - Task
---

# Context Loader

## Purpose

Prepare project context before implementation starts. Runs in isolated `context: fork` to explore codebase without cluttering main conversation.

**Key Principle**: Task Document is read by EVERYONE (context-loader, /si, workers). This skill reads it to understand scope, then explores codebase.

## Input

Receives `task_document_path` - path to task document (tech-decomposition or JTBD)

## Process

### Step 1: Read Task Document

First, understand WHAT we're building:

```
1. Read task document completely
2. Extract:
   - Target modules/services mentioned
   - Key entities/domain concepts
   - Acceptance criteria count
   - File paths mentioned (if any)
```

### Step 2: Explore Related Codebase

Based on task scope, find related code:

```bash
# Find modules mentioned in task
glob "backend/src/modules/**/[module-name]/**/*.ts"

# Find related entities
grep -r "class [EntityName]" backend/src/

# Find existing tests patterns
glob "backend/src/**/*.spec.ts" | head -5
```

### Step 3: Extract Patterns

Analyze found files for patterns:

**Naming Conventions:**
- Entity: `class Name extends AggregateRoot` or plain class?
- Service: `@Injectable()` decorator pattern
- Repository: interface + implementation split
- Controller: RESTful naming

**Code Structure:**
- How are imports organized?
- What's the error handling pattern?
- How are DTOs structured?

**Test Structure:**
- describe/it nesting pattern
- Arrange/Act/Assert style
- Mock patterns used

### Step 4: Check Architecture

Verify DDD layers for Wythm:
```
backend/src/modules/[module]/
├── domain/           # Entities, value objects, domain events
├── application/      # Services, DTOs, use cases
├── infrastructure/   # Repositories impl, external services
└── presentation/     # Controllers, GraphQL resolvers
```

Check dependencies flow: domain → application → infrastructure

### Step 5: Generate CONTEXT_SUMMARY.md

Create summary in task directory:

```markdown
# Project Context Summary

> Generated by context-loader skill
> Task: [task name from document]
> Date: [ISO date]

## Task Scope

**Target Module**: [module name]
**Related Modules**: [list]
**Acceptance Criteria**: [count]

## Related Files Found

### Existing Code
- `path/to/entity.ts` - Main entity
- `path/to/service.ts` - Application service
- `path/to/repository.ts` - Repository implementation

### Test Files
- `path/to/entity.spec.ts` - Entity tests
- `path/to/service.spec.ts` - Service tests

## Patterns to Follow

### Naming
- Entity: `class [Name] extends AggregateRoot<[Props]>`
- Service: `@Injectable() export class [Name]Service`
- Repository: `export class Prisma[Name]Repository implements I[Name]Repository`

### Code Style
- Imports: grouped by type (external, internal, relative)
- Error handling: throw domain exceptions
- DTOs: separate request/response classes

### Test Style
```typescript
describe('[ModuleName]Service', () => {
  describe('[methodName]', () => {
    it('should [behavior] when [condition]', async () => {
      // Arrange
      // Act
      // Assert
    });
  });
});
```

## Architecture Notes

- Domain layer: no external dependencies
- Application layer: uses repository interfaces (DI)
- Infrastructure: Prisma implementations
- [Any specific notes for this module]

## Key Files to Reference

When implementing, reference these as examples:
1. `[path]` - for entity structure
2. `[path]` - for service pattern
3. `[path]` - for test structure
```

## Output

Returns path to generated `CONTEXT_SUMMARY.md` in task directory.

## Usage by /si

```
/si invokes context-loader:
  1. Passes task_document_path
  2. Context-loader runs in fork
  3. Returns CONTEXT_SUMMARY.md path
  4. /si continues with implementation phase
```

## Wythm-Specific Patterns

For this project, also check:
- Prisma schema for entity definitions
- Existing domain events patterns
- Value object implementations
- Module barrel exports (index.ts)
